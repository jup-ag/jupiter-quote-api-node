/* tslint:disable */
/* eslint-disable */
/**
 * Swap API
 * API reference for Jupiter\'s Swap API, including Quote, Swap and Swap Instructions endpoints.  ### Rate Limits Since 1 December 2024, we have updated our API structure. Please refer to https://dev.jup.ag/ for further details on usage and rate limits.  ### Usage - API Wrapper Typescript https://github.com/jup-ag/jupiter-quote-api-node  ### Data Types To Note - Public keys are base58 encoded strings - Raw data such as Vec<u8\\> are base64 encoded strings 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { QuoteResponse } from './QuoteResponse';
import {
    QuoteResponseFromJSON,
    QuoteResponseFromJSONTyped,
    QuoteResponseToJSON,
} from './QuoteResponse';
import type { SwapRequestPrioritizationFeeLamports } from './SwapRequestPrioritizationFeeLamports';
import {
    SwapRequestPrioritizationFeeLamportsFromJSON,
    SwapRequestPrioritizationFeeLamportsFromJSONTyped,
    SwapRequestPrioritizationFeeLamportsToJSON,
} from './SwapRequestPrioritizationFeeLamports';

/**
 * 
 * @export
 * @interface SwapRequest
 */
export interface SwapRequest {
    /**
     * 
     * @type {string}
     * @memberof SwapRequest
     */
    userPublicKey: string;
    /**
     * - Allow a custom payer to pay for the transaction fees and rent of token accounts
     * - Note that users can close their ATAs elsewhere and have you reopen them again, your fees should account for this
     * 
     * @type {string}
     * @memberof SwapRequest
     */
    payer?: string;
    /**
     * - To automatically wrap/unwrap SOL in the transaction, as WSOL is an SPL token while native SOL is not
     * - When true and input mint is SOL, it will wrap the SOL amount to WSOL and swap
     * - When true and output mint is SOL, it will unwrap the WSOL back to SOL
     * - When false and intput mint is SOL, it will use existing WSOL amount to swap
     * - When false and output mint is SOL, it will not unwrap the WSOL to SOL
     * - To set this parameter to false, you need to have the WSOL token account initialized
     * 
     * @type {boolean}
     * @memberof SwapRequest
     */
    wrapAndUnwrapSol?: boolean;
    /**
     * - The default is determined dynamically by the routing engine, allowing us to optimize for compute units, etc
     * - This enables the usage of shared program accounts, this is essential as complex routing will require multiple intermediate token accounts which the user might not have
     * - If true, you do not need to handle the creation of intermediate token accounts for the user
     * - Do note, shared accounts route will fail on some new AMMs (low liquidity token)
     * 
     * @type {boolean}
     * @memberof SwapRequest
     */
    useSharedAccounts?: boolean;
    /**
     * - An initialized token account that will be used to collect fees
     * - The mint of the token account **can only be either the input or output mint of the swap**
     * - Swap API no longer requires the use of the Referral Program
     * - If `platformFeeBps` is passed in `/quote`, the `feeAccount` must be passed as well
     * 
     * @type {string}
     * @memberof SwapRequest
     */
    feeAccount?: string;
    /**
     * - Specify any public key that belongs to you to track the transactions
     * - Useful for integrators to get all the swap transactions from this public key
     * - Query the data using a block explorer like Solscan/SolanaFM or query like Dune/Flipside
     * 
     * @type {string}
     * @memberof SwapRequest
     */
    trackingAccount?: string;
    /**
     * 
     * @type {SwapRequestPrioritizationFeeLamports}
     * @memberof SwapRequest
     */
    prioritizationFeeLamports?: SwapRequestPrioritizationFeeLamports;
    /**
     * - Builds a legacy transaction rather than the default versioned transaction
     * - Used together with `asLegacyTransaction` in `/quote`, otherwise the transaction might be too large
     * 
     * @type {boolean}
     * @memberof SwapRequest
     */
    asLegacyTransaction?: boolean;
    /**
     * - Public key of a token account that will be used to receive the token out of the swap
     * - If not provided, the signer's token account will be used
     * - If provided, we assume that the token account is already initialized
     * - `destinationTokenAccount` and `nativeDestinationAccount` are mutually exclusive
     * 
     * @type {string}
     * @memberof SwapRequest
     */
    destinationTokenAccount?: string;
    /**
     * - Public key of an account that will be used to receive the native SOL token out of the swap
     * - If not provided, the swap will default unwrap the WSOL and transfer the native SOL to the swap authority account
     * - If provided, we will unwrap the WSOL and transfer the native SOL to the account
     * - Only works if the output mint is SOL, is using the V2 instructions and the account passed in is not owned by token program
     * - When sending native SOL to a new account, you must swap at least enough to cover the rent required to create it.
     * - `destinationTokenAccount` and `nativeDestinationAccount` are mutually exclusive
     * 
     * @type {string}
     * @memberof SwapRequest
     */
    nativeDestinationAccount?: string;
    /**
     * - When enabled, it will do a swap simulation to get the compute unit used and set it in ComputeBudget's compute unit limit
     * - This incurs one extra RPC call to simulate this
     * - We recommend to enable this to estimate compute unit correctly and reduce priority fees needed or have higher chance to be included in a block
     * 
     * @type {boolean}
     * @memberof SwapRequest
     */
    dynamicComputeUnitLimit?: boolean;
    /**
     * - When enabled, it will not do any additional RPC calls to check on required accounts
     * - The returned swap transaction will still attempt to create required accounts regardless if it exists or not
     * 
     * @type {boolean}
     * @memberof SwapRequest
     */
    skipUserAccountsRpcCalls?: boolean;
    /**
     * - When enabled, it estimates slippage and apply it in the swap transaction directly, overwriting the `slippageBps` parameter in the quote response.
     * - This is no longer maintained, we are focusing efforts on RTSE on Ultra Swap API
     * 
     * @type {boolean}
     * @memberof SwapRequest
     */
    dynamicSlippage?: boolean;
    /**
     * - To use an exact compute unit price to calculate priority fee
     * - `computeUnitLimit (1400000) * computeUnitPriceMicroLamports`
     * - We recommend using `prioritizationFeeLamports` and `dynamicComputeUnitLimit` instead of passing in your own compute unit price
     * 
     * @type {number}
     * @memberof SwapRequest
     */
    computeUnitPriceMicroLamports?: number;
    /**
     * - Pass in the number of slots we want the transaction to be valid for
     * - Example: If you pass in 10 slots, the transaction will be valid for ~400ms * 10 = approximately 4 seconds before it expires
     * 
     * @type {number}
     * @memberof SwapRequest
     */
    blockhashSlotsToExpiry?: number;
    /**
     * 
     * @type {QuoteResponse}
     * @memberof SwapRequest
     */
    quoteResponse: QuoteResponse;
}

/**
 * Check if a given object implements the SwapRequest interface.
 */
export function instanceOfSwapRequest(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "userPublicKey" in value;
    isInstance = isInstance && "quoteResponse" in value;

    return isInstance;
}

export function SwapRequestFromJSON(json: any): SwapRequest {
    return SwapRequestFromJSONTyped(json, false);
}

export function SwapRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): SwapRequest {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'userPublicKey': json['userPublicKey'],
        'payer': !exists(json, 'payer') ? undefined : json['payer'],
        'wrapAndUnwrapSol': !exists(json, 'wrapAndUnwrapSol') ? undefined : json['wrapAndUnwrapSol'],
        'useSharedAccounts': !exists(json, 'useSharedAccounts') ? undefined : json['useSharedAccounts'],
        'feeAccount': !exists(json, 'feeAccount') ? undefined : json['feeAccount'],
        'trackingAccount': !exists(json, 'trackingAccount') ? undefined : json['trackingAccount'],
        'prioritizationFeeLamports': !exists(json, 'prioritizationFeeLamports') ? undefined : SwapRequestPrioritizationFeeLamportsFromJSON(json['prioritizationFeeLamports']),
        'asLegacyTransaction': !exists(json, 'asLegacyTransaction') ? undefined : json['asLegacyTransaction'],
        'destinationTokenAccount': !exists(json, 'destinationTokenAccount') ? undefined : json['destinationTokenAccount'],
        'nativeDestinationAccount': !exists(json, 'nativeDestinationAccount') ? undefined : json['nativeDestinationAccount'],
        'dynamicComputeUnitLimit': !exists(json, 'dynamicComputeUnitLimit') ? undefined : json['dynamicComputeUnitLimit'],
        'skipUserAccountsRpcCalls': !exists(json, 'skipUserAccountsRpcCalls') ? undefined : json['skipUserAccountsRpcCalls'],
        'dynamicSlippage': !exists(json, 'dynamicSlippage') ? undefined : json['dynamicSlippage'],
        'computeUnitPriceMicroLamports': !exists(json, 'computeUnitPriceMicroLamports') ? undefined : json['computeUnitPriceMicroLamports'],
        'blockhashSlotsToExpiry': !exists(json, 'blockhashSlotsToExpiry') ? undefined : json['blockhashSlotsToExpiry'],
        'quoteResponse': QuoteResponseFromJSON(json['quoteResponse']),
    };
}

export function SwapRequestToJSON(value?: SwapRequest | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'userPublicKey': value.userPublicKey,
        'payer': value.payer,
        'wrapAndUnwrapSol': value.wrapAndUnwrapSol,
        'useSharedAccounts': value.useSharedAccounts,
        'feeAccount': value.feeAccount,
        'trackingAccount': value.trackingAccount,
        'prioritizationFeeLamports': SwapRequestPrioritizationFeeLamportsToJSON(value.prioritizationFeeLamports),
        'asLegacyTransaction': value.asLegacyTransaction,
        'destinationTokenAccount': value.destinationTokenAccount,
        'nativeDestinationAccount': value.nativeDestinationAccount,
        'dynamicComputeUnitLimit': value.dynamicComputeUnitLimit,
        'skipUserAccountsRpcCalls': value.skipUserAccountsRpcCalls,
        'dynamicSlippage': value.dynamicSlippage,
        'computeUnitPriceMicroLamports': value.computeUnitPriceMicroLamports,
        'blockhashSlotsToExpiry': value.blockhashSlotsToExpiry,
        'quoteResponse': QuoteResponseToJSON(value.quoteResponse),
    };
}

