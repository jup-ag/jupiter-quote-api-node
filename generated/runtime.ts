/* eslint-disable */
/**
 * Swap API
 * API reference for Jupiter's Swap API.
 * The version of the OpenAPI document: 1.0.0
 * * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

// --- BASE CONFIGURATION ---

export const BASE_PATH = "https://api.jup.ag/swap/v1".replace(/\/+$/, "");

/**
 * Interface defining all parameters available for configuring the API client.
 */
export interface ConfigurationParameters {
    basePath?: string; // override base path for API calls
    fetchApi?: FetchAPI; // override for the fetch implementation (e.g., using node-fetch)
    middleware?: Middleware[]; // middleware functions applied before/after requests
    queryParamsStringify?: (params: HTTPQuery) => string; // custom function for serializing query strings
    username?: string; // basic security: username
    password?: string; // basic security: password
    apiKey?: string | Promise<string> | ((name: string) => string | Promise<string>); // API key security
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // OAuth2 token security
    headers?: HTTPHeaders; // default headers for all requests
    credentials?: RequestCredentials; // value for the credentials parameter
}

export class Configuration {
    // Made configuration parameters public and readonly for immutability preference
    public readonly basePath: string;
    public readonly fetchApi?: FetchAPI;
    public readonly middleware: Middleware[];
    public readonly queryParamsStringify: (params: HTTPQuery) => string;
    public readonly username?: string;
    public readonly password?: string;
    public readonly headers?: HTTPHeaders;
    public readonly credentials?: RequestCredentials;

    constructor(configuration: ConfigurationParameters = {}) {
        this.basePath = configuration.basePath != null ? configuration.basePath : BASE_PATH;
        this.fetchApi = configuration.fetchApi;
        this.middleware = configuration.middleware || [];
        this.queryParamsStringify = configuration.queryParamsStringify || querystring;
        this.username = configuration.username;
        this.password = configuration.password;
        this.headers = configuration.headers;
        this.credentials = configuration.credentials;
    }

    get apiKey(): ((name: string) => string | Promise<string>) | undefined {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }

    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            // Optimization: If the token is a static string, return it asynchronously without extra overhead.
            return typeof accessToken === 'function' ? accessToken : async () => accessToken;
        }
        return undefined;
    }
}

export const DefaultConfig = new Configuration();

// --- BASE API CLASS ---

/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {

    // Regex for checking JSON MIME types, made static and private
    private static readonly jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
    
    // Middleware is now managed within the Configuration and cloned explicitly
    private readonly middleware: Middleware[]; 

    constructor(protected configuration = DefaultConfig) {
        this.middleware = configuration.middleware;
    }

    /**
     * Creates a new instance of the API class with additional middleware applied.
     */
    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]): T {
        // Use custom clone method
        const next = this.clone<T>(); 
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }

    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware<T>(...middlewares);
    }

    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware<T>(...middlewares);
    }

    /**
     * Check if the given MIME is a JSON MIME.
     */
    protected isJsonMime(mime: string | null | undefined): boolean {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }

    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        
        if (response && (response.status >= 200 && response.status < 300)) {
            return response;
        }
        throw new ResponseError(response, `API call failed with status: ${response.status}`);
    }

    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {
        let url = this.configuration.basePath + context.path;
        
        // Append query string only if parameters exist
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }

        // Merge default headers and request-specific headers
        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});

        const initOverrideFn =
            typeof initOverrides === "function"
                ? initOverrides
                : async () => initOverrides;

        const initParams: HTTPRequestInit = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials,
        };

        const overriddenInit: RequestInit = {
            ...initParams,
            ...(await initOverrideFn({
                init: initParams,
                context,
            }))
        };

        let body: any;
        if (isFormData(overriddenInit.body)
            || (overriddenInit.body instanceof URLSearchParams)
            || isBlob(overriddenInit.body)) {
            body = overriddenInit.body;
        } else if (this.isJsonMime(headers['Content-Type'])) {
            // Stringify body for JSON requests
            body = JSON.stringify(overriddenInit.body);
        } else {
            body = overriddenInit.body;
        }

        const init: RequestInit = {
            ...overriddenInit,
            body
        };

        return { url, init };
    }

    private fetchApi = async (url: string, init: RequestInit) => {
        let fetchParams: FetchParams = { url, init };
        
        // 1. Pre-middlewares
        for (const middleware of this.middleware) {
            if (middleware.pre) {
                // Ensure correct cloning is done within the middleware if needed
                fetchParams = await middleware.pre(fetchParams) || fetchParams; 
            }
        }
        
        let response: Response | undefined = undefined;
        try {
            // 2. Fetch call
            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
        } catch (e) {
            // 3. Error-middlewares
            for (const middleware of this.middleware) {
                if (middleware.onError) {
                    // Pass a clone of the response if available, or undefined
                    response = await middleware.onError({
                        ...fetchParams,
                        error: e,
                        response: response ? response.clone() : undefined,
                    }) || response;
                }
            }
            if (response === undefined) {
              if (e instanceof Error) {
                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
              } else {
                throw e;
              }
            }
        }
        
        // 4. Post-middlewares
        for (const middleware of this.middleware) {
            if (middleware.post) {
                // Pass a clone of the response for middleware consumption
                response = await middleware.post({
                    ...fetchParams,
                    response: response.clone(),
                }) || response;
            }
        }
        return response;
    }

    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    private clone<T extends BaseAPI>(this: T): T {
        const constructor = this.constructor as any;
        const next = new constructor(this.configuration);
        // Explicitly clone the middleware array
        next.middleware = this.middleware.slice();
        return next;
    }
};

// --- UTILITY FUNCTIONS ---

function isBlob(value: any): value is Blob {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}

function isFormData(value: any): value is FormData {
    return typeof FormData !== "undefined" && value instanceof FormData;
}

/**
 * Serializes an object of query parameters into a URL query string.
 */
export function querystring(params: HTTPQuery, prefix: string = ''): string {
    const parts: string[] = [];
    
    // Use Object.entries for better iteration
    for (const [key, value] of Object.entries(params)) {
        // Use a dedicated helper to process the single key/value pair
        const part = querystringSingleKey(key, value, prefix);
        if (part.length > 0) {
            parts.push(part);
        }
    }
    return parts.join('&');
}

// Helper function simplified for cleaner recursion
function querystringSingleKey(key
